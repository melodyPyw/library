(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{250:function(n,e,t){"use strict";t.r(e);var s=t(28),o=Object(s.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("p",[this._v("Why为什么要做前端工程化？\n收敛和约束\n收敛\n收敛各条业务线技术栈，抽离公共组件库、公共项目配置，减少团队重负性工作\n约束\n保证代码的健壮性，统一团队的代码风格\nWhat什么是前端工程化？\n模块化\n模块化划分\ncommonjs\n通过module.exports的方式导出模块，通过require的方式引入模块\ncommonjs导出的值是值的拷贝，es module导出的是值的引用\ncommonjs可以写在动态语法的判断里，ES Module静态语法只能写在顶层\nes module\n通过export default的方式导出模块，通过import from的方式引入模块，如果需要动态引入模块可以通过import()方法引入\nes module的引入方式是静态的，所以不能放在条件判断语句和循环语句中引入\nwebpack 性能优化中的tree shaking依赖的就是es module的静态导入，判断模块这个模块中没有使用的代码，然后将这个代码去掉\namd\namd的引用方式是依赖前置，在一个模块中，需要引入外部的模块需要在头部预先引入，代表框架require.js\ncmd\namd的引用方式是依赖就近，需要的时候在引入，代表框架sea.js\nweb-component\n微前端\n模块化的好处：解决代码以来问题，实现按需加载\n组件化\n基础组件\n各大组件库(antd, element)\n自己封装的公共组件\n业务组件\n和业务紧密结合的组件\nnpm包管理\nlerna\n组件化的好处：实现代码复用，和功能变更问题。\n自动化(脚本化，使用脚本实现需要手动操作的工作)\nwebpack、gulp、gurnt这一类构建工具\nbabel\nast\nSource Map\n按需加载\nloader\nplugin\n压缩代码\n发布流程，CI/CD(持续集成持续测试持续部署)\nhusky代码预提交校验\nlint-staged构建前端工作流\n线上版本快速回退\n自动化好处：解决开发环境和生产环境差异问题，减少重复的工作。\n规范化\n微观代码质量(可以通过自动化实现持续集成)\neslint规范代码质量，自定义lint\nstylelint规范css质量\n使用commit-message规范git commit提交信息\ngit branch管理规范\n使用prettier进行代码格式化，保证团队风格统一\n引入TS，进行静态代码校验\n使用jest和cypress，进行自动化测试\n宏观代码质量\ncode review\n保证代码健壮性，可拓展性，维护性\n规范化的好处：保证代码的健壮性，统一团队的代码风格\n可视化\n数据监控，产品数据可视化\n异常数据监控\n错误日志\n错误闸值报警，接入钉钉/微信机器人\nsentry\n用户行为监控\n前端声明式数据埋点\n无痕埋点技术\n性能监控\nlighthouse\n可视化搭建\n智能生成h5页面\n智能生成后台管理系统页面\n可视化的好处：实现线上报错监控，减少线上代码错误\nHow怎么做前端工程化？")])])}),[],!1,null,null,null);e.default=o.exports}}]);