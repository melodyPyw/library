# 微前端设计分析

## 为什么使用微前端

> 使用微前端，不是因为这个技术先进，而是因为它能解决现有业务的痛点

区别于后台的微服务技术，前端使用微前端的主要原因是:

> 将老业务`聚合`，而不是`解耦`。
>
> 后台使用微服务这个技术的一大原因是`解耦`: 后台业务复杂，链条太长，逻辑不清晰。
>
> 而微前端恰恰相反，使用这个技术的主要原因是`聚合`: 解决历史遗留的系统，将老系统和新的系统聚合在一起，降低系统之间的跳转频率，减少系统之间数据传递的代价。

比如有一个场景: 不同业务线之间的系统强依赖，其中一个系统依赖另一条业务线的系统，通常的做法是，这个系统创建好一个数据之后，再由后端将这个数据提交给另一个系统的后端。然后用户根据ID去另外一个系统操作。

但是这样有几个问题:

- 系统之间跳转频率太高，对用户不友好
- 不同系统之间数据传递和状态管理麻烦，强依赖后端
- 模块复用率差，通常两个部门有同一个业务功能时，都是把对方系统的页面代码拷贝过来，无法实现模块复用性
- 不允许技术栈混用，比如有一个react系统强依赖另一个vue系统的功能模块，无法直接拷贝模块使用，只能重写
- 跨系统之间的数据传递的沟通成本过高，如果有一个跨系统之间的数据传递需求，通常需要两条业务线之间的钱后端一起到场制定，时间成本高，效率太低。

## 什么是微前端

简单来讲，微前端的理念类似于微服务：

将庞大的系统拆分成小的模块，用装载器的方式将模块加载到页面中

>将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品

## 怎么做微前端

微前端架构会遇到的几个问题

- 路由管理
- 状态管理
- 隔绝变量污染
- 版本控制
- 统一的工具函数库

###路由管理

使用h5的history路由，子应用需要做一下兼容，将命名空间挂载到二级路径上面

Https://localhost:3000/data-base/home



### 状态管理

由根项目统一创建状态管理工具，并且将`store`的句柄(也就是store的引用地址)抛给子项目，然后由子项目加载。

![avatar](/Users/pengyouwei/Desktop/library/docs/web-project/micro-project/micro-data-project.png)

具体过程如上图所示:

1. 根项目读取各个子项目中的micro.config.js配置文件，创建store，并且将store的引用抛出给子组件
2. 子项目拿到store，调用`store.getState(namespace: string): state`方法，传入自己的命名空间，返回命名空间对应的数据
3. 子项目将state绑定到vuex或者redux中，并且抛出一个更新state数据的方法`store.listenerState(namespace:string, handleChange: Function):void`，listenerState方法可以多次调用，并传入需要监听state变化的方法，每当state发生变化，都会调用所有的handleChange方法，并且将新的state作为参数，传递给handleChange
4. handleChange方法被调用之后，去更新子项目中状态管理工具(vuex, redux)的数据，并且重新渲染UI
5. 如果子项目需要更新其他子项目的状态，需要通过提交state的方法来更新`store.dispatchState(namespace: string, state: any)`，store的dispatchState方法被调用后，拿到子项目中对应命名空间的handleChange[]方法的数组，更新对应命名空间下面的所有handleChange方法。

### 隔绝变量污染

通过eslint，禁止子项目往window和其他公共对象上面挂载和修改属性。保证所有项目的运行一致，不会出现变量污染的情况。

### 版本控制

通过公共脚手架，将node_modules，package.json，webpack.config.js隐藏，使子项目无法更新和修改项目依赖。需要更新和修改的依赖的，只能通过公共脚手架统一更新，保证子项目中项目依赖一致。

### 统一的工具函数库

由根组件统一引入，子项目只需要像npm一样引入即可。